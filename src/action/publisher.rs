//! Implement observer design pattern to implement control system based off of polling of `Input` objects
//!
//! # Description
//! The goal of a dedicated `Publisher` implementation being stored as a field is to add a layer of indirection
//! between `Input` and `Output` to serve as a bridge. Both input and output should be unaware of the other.
//! However, events generated by Input::read() are routed to Publisher::notify() which is propagated to
//! Subscriber implementations and therefore events are passed to outputs.
//!
//! `Publisher` objects should be stored a struct which implements `Input`. When `Input::read()` is called,
//! `Input::publisher().notify()` should also be called as well. `notify()` should thereby call
//! `Subscriber::evaluate()` on any listeners.

use crate::action::{Action, Comparison, SchedRoutineHandler, ThresholdAction};
use crate::io::{DeferredDevice, IOEvent, RawValue};

pub type BoxedAction = Box<dyn Action>;

/// Trait to implement on Input objects
pub trait Publisher {
    fn subscribers(&self) -> &[BoxedAction];
    fn subscribe(&mut self, subscriber: BoxedAction);

    fn notify(&mut self, data: &IOEvent);
}

/// Concrete instance of publisher object
#[derive(Default)]
pub struct PublisherInstance {
    actions: Vec<BoxedAction>,
    scheduled: SchedRoutineHandler,
}

impl PublisherInstance {
    /// Attempt to run scheduled `Routine` structs
    pub fn attempt_routines(&mut self) {
        self.scheduled.attempt_routines()
    }

    pub fn attach_threshold(&mut self,
                            name: &str,
                            threshold: RawValue,
                            trigger: Comparison,
                            output: Option<DeferredDevice>,
    ) -> &mut Self {
        let action = ThresholdAction::new(name.to_string(), threshold, trigger, output)
            .into_boxed();
        self.subscribe(action);
        self
    }
}

impl Publisher for PublisherInstance {
    fn subscribers(&self) -> &[BoxedAction] {
        &self.actions
    }

    fn subscribe(&mut self, subscriber: BoxedAction) {
        self.actions.push(subscriber)
    }

    /// Call [`Action::evaluate()`] on all associated [`Action`] implementations.
    /// TODO: scheduled routines should be returned, then added to `scheduled`
    fn notify(&mut self, data: &IOEvent) {
        for subscriber in self.actions.iter_mut() {
            // TODO: `IOEvent` shall be sent to `OutputDevice` and shall be logged
            // TODO: results should be aggregated
            subscriber.evaluate(data);
        }
    }
}
